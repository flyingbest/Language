# C++
---

### 포인터

변수는 선언되면 할당된 메모리 공간이 컴파일 타임에 선택된다. 프로그램이 실행 중일 때는 이 메모리 공간을 변경하거나 기존 메모리 공간에 더 많은 공간을 추가할 수 없다는 뜻.

> 스택

> 힙(heap)

흔히 자유 저장소라고 부르는 메모리 영역.

힙은 미할당 메모리로서, 요청에 따라 필요한 공간이 할당된다. 힙은 운영체제가 관리. 일정 공간이 할당되면 메모리를 할당한 원래 코드, 또는 메모리 할당기로부터 해당 주소를 제공받은 코드가 사용한다. 포인터를 사용하면 이 메모리에 접근 가능.

반환해야 하는 메모리를 그때그때 제대로 반환하지 않아서 생기는 현상 = 메모리 누수(memory leak).

포인터 기호 표.

동작|필요한 기호|예시
---|---|---
포인터 선언|\*|int \*px;
포인터에 담긴 주소 가져오기|없음|cout << px;
포인터에 담긴 주소 설정하기|없음|int \*px; px=주소;
해당 주소에 있는 값 가져오기|\*|cout << \*px;
해당 주소에 새로운 값 설정하기|\*|\*px=5;
변수 선언하기|없음|int x;
변수에 저장된 값 가져오기|없음|int x; cout << x;
변수에 저장된 값 설정하기|없음|int x; x=5;
변수의 주소 가져오기|&|int x; int\* px; px=&x;
변수의 주소 설정하기|가능하지 않음|변수는 주소를 변경할 수 없음.


> 레퍼런스

경우에 따라서는 포인터가 제공하는 기능 가운데 일부만 필요할 때가 있다. 가령, 큰 데이터의 복사본을 별도로 만들지 않으려면 포인터가 필수다. 하지만 그렇다고 해도 포인터의 막강한 능력 전부가 필요하지는 않다. 이런 상황에서는 레퍼런스만으로도 충분하다. 레퍼런스는 다른 변수를 가리키는 변수로서, 그 다른 변수와 동일한 메모리 위치를 서로 공유한다. 하지만 사용방법은 일반적인 변수를 다룰 때와 별반 다르지 않다. 한마디로 레퍼런스는 포인터의 간소화 버전이다. 레퍼런스에는 포인터가 가리키는 값을 사용하거나 레퍼런스에 값을 대입할 때 애스터리스크나 앰퍼샌드를 추가해야 하는 특별한 문법이 필요없다. 하지만 레퍼런스는 언제나 유효한 메모리만을 가리켜야 한다. 레퍼런스를 선언할 때는 앰퍼샌드를 추가한다.

```
int &ref;
```

이렇게 선언하면 안 된다. 레퍼런스는 반드시 초기화해야 하기 때문이다. (레퍼런스는 언제나 유효한 메모리만을 가리켜야 한다는 사실을 잊지 말자.)

```
int x = 5;
int &ref = x; //x 앞에 앰퍼샌드를 두지 않는다는 점에 유의!
```

레퍼런스도 포인터처럼 같은 그림으로 나타낼 수 있다. 다만, 레퍼런스를 사용할 때 우리가 가져오는 것은 레퍼런스가 가리키는 메모리의 값이지 그 메모리의 주소가 아니다.
여기서 ref 변수의 실제 메모리에는 x 변수의 메모리를 가리키는 포인터가 담겨있다. 여러분이 ref에 접근할 때 컴파일러는 여러분이 ref의 주소가 아닌 ref가 가리키는 실제 값에 접근하는 것으로 이해한다. 

레퍼런스는 언제나 원래 대상을 가리키기 때문에 함수로 넘어오는 원래 대상을 복사하거나 수정하지 않아도 된다.

```
void swap(int& left, int& right){
	int tmp = right;
	right = left;
	left = tmp;
}
```
-----

# 사이트 참조 공부

> 함수 오버로딩(Function Overloading)

함수명은 같으며 인자의 자료형이나 수가 다른 함수의 선언을 허용하는 것.

특징 : 함수명이 같아야 하며, 매개변수의 수가 다르거나, 아니면 그 매개변수의 수가 같고 자료형이 달라야만 한다. 함수의 반환형은 같아도 되고, 달라도 상관없다.


> 구조체 : struct.cpp 파일안에

> 클래스(class)

클래스는 구조체와 비슷하지만, 어떤 메소드와 데이터가 클래스 구현 내부에 존재할지와 어떤 메소드가 클래스 사용자를 위한 것인지 정의하는 능력이 더해졌다. 

_구조체와 클래스의 차이점_

- 기본 접근 제한자의 차이.

1. 구조체 : 기본 접근 제한자가 public
2. 클래스 : 기본 접근 제한자가 private

이제 부터가 객체 지향 프로그래밍(OPP, Object-Oriented Programming)의 시작!

클래스 변수(인스턴스?) 를 만드는 것이 '객체(object)'를 생성한다. 라고 표현.

_객체와 인스턴스의 차이_

객체는 선언을 의미! Car tico; 의 tico 처럼

이때 tico는 NULL 값을 가지고 있다. 왜냐하면 new와 같은 연산자를 이용해 클래스로부터 실체화를 하지 않았기 때문에..

즉, 어떠한 메모리도 객체에 자지되어 있지 않았다. 

클래스의 인스턴스는 Car tico = new Car(); 처럼 메모리가 객체에 의해 차지(실체화)되어 진 것.




